// Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÏàòÎì§
let canvas, ctx;
let gameState = 'ready'; // 'ready', 'playing', 'paused', 'gameOver'
let gameInterval;
let gameStartTime = 0;
let totalPlayTime = 0;

// Í≤åÏûÑ Í∞ùÏ≤¥Îì§
let snake = [];
let foods = []; // Ïó¨Îü¨ ÏùåÏãùÏùÑ ÏúÑÌïú Î∞∞Ïó¥
let obstacles = []; // Ïû•Ïï†Î¨º Î∞∞Ïó¥
let direction = { x: 0, y: 0 };
let nextDirection = { x: 0, y: 0 };

// Í≤åÏûÑ ÏÑ§Ï†ï
const GAME_CONFIG = {
    gridSize: 20,
    canvasSize: 600
};

// ÏùåÏãù ÌÉÄÏûÖ Ï†ïÏùò
const FOOD_TYPES = {
    APPLE: {
        type: 'apple',
        score: 10,
        lengthChange: 1,
        emoji: 'üçé',
        duration: null, // ÏÇ¨ÎùºÏßÄÏßÄ ÏïäÏùå
        speedEffect: null
    },
    GOLDEN: {
        type: 'golden',
        score: 20,
        lengthChange: 0,
        emoji: 'üçè',
        duration: 5000, // 5Ï¥à
        speedEffect: 'slow' // ÏÜçÎèÑ Í∞êÏÜå
    },
    POISON: {
        type: 'poison',
        score: -15,
        lengthChange: 2,
        emoji: 'üçÑ',
        duration: 10000, // 10Ï¥à
        speedEffect: 'freeze' // 1.5Ï¥à Î©àÏ∂§
    }
};

// Ïû•Ïï†Î¨º ÌÉÄÏûÖ Ï†ïÏùò
const OBSTACLE_TYPES = {
    STATIC: {
        type: 'static',
        color: '#666666',
        moving: false,
        getDuration: () => 15000 + Math.random() * 10000 // 15-25Ï¥à ÎûúÎç§
    },
    MOVING: {
        type: 'moving',
        color: '#4488ff',
        moving: true,
        speed: 1000, // 1Ï¥àÎßàÎã§ Ïù¥Îèô
        getDuration: () => 20000 + Math.random() * 15000 // 20-35Ï¥à ÎûúÎç§
    }
};

// Í≤åÏûÑ ÏÉÅÌÉú
let gameStats = {
    score: 0,
    snakeLength: 1,
    speed: 1,
    highScore: parseInt(localStorage.getItem('snakeHighScore')) || 0,
    maxLength: parseInt(localStorage.getItem('snakeMaxLength')) || 1,
    foodEaten: 0,
    gameSpeed: 200, // Ï¥àÍ∏∞ ÏÜçÎèÑ
    slowEffectTime: 0, // ÏÜçÎèÑ Í∞êÏÜå Ìö®Í≥º ÎÇ®ÏùÄ ÏãúÍ∞Ñ
    freezeTime: 0 // Î©àÏ∂§ Ìö®Í≥º ÎÇ®ÏùÄ ÏãúÍ∞Ñ
};

// Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞
let allTimeStats = {
    totalGames: parseInt(localStorage.getItem('snakeTotalGames')) || 0,
    totalFood: parseInt(localStorage.getItem('snakeTotalFood')) || 0,
    totalPlayTime: parseInt(localStorage.getItem('snakePlayTime')) || 0,
    maxSpeed: parseInt(localStorage.getItem('snakeMaxSpeed')) || 1,
    totalSurvivalTime: parseInt(localStorage.getItem('snakeSurvivalTime')) || 0
};

// DOM ÏöîÏÜåÎì§
let elements = {};

// ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞Ìôî
document.addEventListener('DOMContentLoaded', () => {
    elements = {
        score: document.getElementById('score'),
        snakeLength: document.getElementById('snakeLength'),
        speed: document.getElementById('speed'),
        gameInfo: document.getElementById('gameInfo'),
        highScore: document.getElementById('highScore'),
        maxLength: document.getElementById('maxLength'),
        foodEaten: document.getElementById('foodEaten'),
        gameOverlay: document.getElementById('gameOverlay'),
        overlayTitle: document.getElementById('overlayTitle'),
        overlayMessage: document.getElementById('overlayMessage'),
        gameOverModal: document.getElementById('gameOverModal'),
        modalTitle: document.getElementById('modalTitle'),
        modalMessage: document.getElementById('modalMessage'),
        finalScore: document.getElementById('finalScore'),
        finalLength: document.getElementById('finalLength'),
        finalFood: document.getElementById('finalFood'),
        mobileControls: document.getElementById('mobileControls'),
        helpModal: document.getElementById('helpModal'),
        statsModal: document.getElementById('statsModal')
    };

    init();
});

// Ï¥àÍ∏∞Ìôî
function init() {
    canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    
    ctx = canvas.getContext('2d');
    
    resizeCanvas();
    initializeGame();
    setupEventListeners();
    updateUI();
    draw();
}

function resizeCanvas() {
    if (!canvas) return;
    
    const container = canvas.parentElement;
    const maxSize = Math.min(600, container.clientWidth - 40);
    
    canvas.width = maxSize;
    canvas.height = maxSize;
    canvas.style.width = maxSize + 'px';
    canvas.style.height = maxSize + 'px';
    
    GAME_CONFIG.gridSize = maxSize / 30; // 30x30 Í∑∏Î¶¨Îìú
}

function initializeGame() {
    const centerX = Math.floor((canvas.width / GAME_CONFIG.gridSize) / 2);
    const centerY = Math.floor((canvas.height / GAME_CONFIG.gridSize) / 2);
    
    snake = [{ x: centerX, y: centerY }];
    direction = { x: 0, y: 0 };
    nextDirection = { x: 0, y: 0 };
    foods = [];
    obstacles = [];
    
    // Í∏∞Î≥∏ ÏÇ¨Í≥º ÏÉùÏÑ±
    generateFood(FOOD_TYPES.APPLE);
    
    gameState = 'ready';
}

function generateFood(foodType) {
    if (!canvas) return;
    
    const gridWidth = Math.floor(canvas.width / GAME_CONFIG.gridSize);
    const gridHeight = Math.floor(canvas.height / GAME_CONFIG.gridSize);
    
    let newFood;
    let attempts = 0;
    
    do {
        newFood = {
            x: Math.floor(Math.random() * gridWidth),
            y: Math.floor(Math.random() * gridHeight),
            ...foodType,
            createdAt: Date.now()
        };
        attempts++;
    } while (isPositionOccupied(newFood.x, newFood.y) && attempts < 50);
    
    if (attempts < 50) {
        foods.push(newFood);
        
        // ÏãúÍ∞Ñ Ï†úÌïúÏù¥ ÏûàÎäî ÏùåÏãùÏùÄ ÏûêÎèôÏúºÎ°ú Ï†úÍ±∞
        if (newFood.duration) {
            setTimeout(() => {
                removeFood(newFood);
            }, newFood.duration);
        }
    }
}

function removeFood(targetFood) {
    foods = foods.filter(food => food !== targetFood);
}

function isPositionOccupied(x, y) {
    // Î±ÄÏùò ÏúÑÏπò ÌôïÏù∏
    if (snake.some(segment => segment.x === x && segment.y === y)) {
        return true;
    }
    
    // Îã§Î•∏ ÏùåÏãùÏùò ÏúÑÏπò ÌôïÏù∏
    if (foods.some(food => food.x === x && food.y === y)) {
        return true;
    }
    
    // Ïû•Ïï†Î¨ºÏùò ÏúÑÏπò ÌôïÏù∏
    if (obstacles.some(obstacle => obstacle.x === x && obstacle.y === y)) {
        return true;
    }
    
    return false;
}

function generateObstacle(obstacleType) {
    if (!canvas || obstacles.length >= 3) return;
    
    const gridWidth = Math.floor(canvas.width / GAME_CONFIG.gridSize);
    const gridHeight = Math.floor(canvas.height / GAME_CONFIG.gridSize);
    
    let newObstacle;
    let attempts = 0;
    
    do {
        newObstacle = {
            x: Math.floor(Math.random() * gridWidth),
            y: Math.floor(Math.random() * gridHeight),
            ...obstacleType,
            direction: obstacleType.moving ? { 
                x: Math.random() > 0.5 ? 1 : -1, 
                y: Math.random() > 0.5 ? 1 : -1 
            } : null,
            lastMoved: Date.now(),
            createdAt: Date.now(),
            duration: obstacleType.getDuration() // ÎûúÎç§ ÏßÄÏÜçÏãúÍ∞Ñ
        };
        attempts++;
    } while (isPositionOccupied(newObstacle.x, newObstacle.y) && attempts < 50);
    
    if (attempts < 50) {
        obstacles.push(newObstacle);
        
        // ÎûúÎç§ ÏãúÍ∞Ñ ÌõÑ Ïû•Ïï†Î¨º Ï†úÍ±∞ÌïòÍ≥† ÏÉàÎ°ú ÏÉùÏÑ±
        setTimeout(() => {
            removeObstacle(newObstacle);
            // 2-5Ï¥à ÌõÑ ÏÉàÎ°úÏö¥ Ïû•Ïï†Î¨º ÏÉùÏÑ± ÏãúÎèÑ
            const respawnDelay = 2000 + Math.random() * 3000; // 2-5Ï¥à ÎûúÎç§
            setTimeout(() => {
                if (gameState === 'playing') {
                    // Í∞ôÏùÄ ÌÉÄÏûÖÏùò Ïû•Ïï†Î¨º Ïû¨ÏÉùÏÑ± ÏãúÎèÑ
                    if (obstacles.length < 3) {
                        generateObstacle(obstacleType);
                    }
                }
            }, respawnDelay);
        }, newObstacle.duration);
    }
}

function removeObstacle(targetObstacle) {
    obstacles = obstacles.filter(obstacle => obstacle !== targetObstacle);
}

function moveObstacles() {
    const now = Date.now();
    
    obstacles.forEach(obstacle => {
        if (obstacle.moving && now - obstacle.lastMoved > obstacle.speed) {
            const gridWidth = Math.floor(canvas.width / GAME_CONFIG.gridSize);
            const gridHeight = Math.floor(canvas.height / GAME_CONFIG.gridSize);
            
            // ÏÉà ÏúÑÏπò Í≥ÑÏÇ∞
            let newX = obstacle.x + obstacle.direction.x;
            let newY = obstacle.y + obstacle.direction.y;
            
            // Î≤ΩÏóê ÎãøÏúºÎ©¥ Î∞©Ìñ• Î∞îÍæ∏Í∏∞
            if (newX < 0 || newX >= gridWidth) {
                obstacle.direction.x *= -1;
                newX = obstacle.x + obstacle.direction.x;
            }
            if (newY < 0 || newY >= gridHeight) {
                obstacle.direction.y *= -1;
                newY = obstacle.y + obstacle.direction.y;
            }
            
            // Îã§Î•∏ Í∞ùÏ≤¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÏúºÎ©¥ Ïù¥Îèô
            if (!isPositionOccupiedExcept(newX, newY, obstacle)) {
                obstacle.x = newX;
                obstacle.y = newY;
            } else {
                // Í≤πÏπòÎ©¥ Î∞©Ìñ• Î∞îÍæ∏Í∏∞
                obstacle.direction.x = Math.random() > 0.5 ? 1 : -1;
                obstacle.direction.y = Math.random() > 0.5 ? 1 : -1;
            }
            
            obstacle.lastMoved = now;
        }
    });
}

function isPositionOccupiedExcept(x, y, exceptObject) {
    // Î±ÄÏùò ÏúÑÏπò ÌôïÏù∏
    if (snake.some(segment => segment.x === x && segment.y === y)) {
        return true;
    }
    
    // Îã§Î•∏ ÏùåÏãùÏùò ÏúÑÏπò ÌôïÏù∏
    if (foods.some(food => food.x === x && food.y === y)) {
        return true;
    }
    
    // Îã§Î•∏ Ïû•Ïï†Î¨ºÏùò ÏúÑÏπò ÌôïÏù∏ (ÏûêÍ∏∞ ÏûêÏã† Ï†úÏô∏)
    if (obstacles.some(obstacle => obstacle !== exceptObject && obstacle.x === x && obstacle.y === y)) {
        return true;
    }
    
    return false;
}

// Í≤åÏûÑ Ï†úÏñ¥ Ìï®ÏàòÎì§
function startGame() {
    if (gameState === 'ready') {
        // Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäºÏúºÎ°ú ÏãúÏûëÌï† ÎïåÎßå ÎûúÎç§ Î∞©Ìñ• ÏÑ§Ï†ï
        const directions = [
            { x: 0, y: -1 }, // ÏúÑ
            { x: 0, y: 1 },  // ÏïÑÎûò
            { x: -1, y: 0 }, // ÏôºÏ™Ω
            { x: 1, y: 0 }   // Ïò§Î•∏Ï™Ω
        ];
        const randomDirection = directions[Math.floor(Math.random() * directions.length)];
        direction = { ...randomDirection };
        nextDirection = { ...randomDirection };
        
        gameState = 'playing';
        gameStartTime = Date.now();
        
        if (elements.gameOverlay) {
            elements.gameOverlay.classList.add('hidden');
        }
        if (elements.gameInfo) {
            elements.gameInfo.textContent = 'Î∞©Ìñ•ÌÇ§Î°ú Î±ÄÏùÑ Ï°∞Ï¢ÖÌïòÏÑ∏Ïöî!';
        }
        
        gameInterval = setInterval(gameLoop, gameStats.gameSpeed);
        updateGameButton();
    }
}

function startNewGame() {
    if (gameState === 'ready') {
        startGame();
    }
}

function pauseGame() {
    if (gameState === 'playing') {
        gameState = 'paused';
        clearInterval(gameInterval);
        
        if (elements.gameOverlay) {
            elements.gameOverlay.classList.remove('hidden');
        }
        if (elements.overlayTitle) {
            elements.overlayTitle.textContent = '‚è∏Ô∏è Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ';
        }
        if (elements.overlayMessage) {
            elements.overlayMessage.textContent = 'Ïä§ÌéòÏù¥Ïä§Î∞îÎ•º ÎàåÎü¨ Í≥ÑÏÜçÌïòÏÑ∏Ïöî';
        }
        if (elements.gameInfo) {
            elements.gameInfo.textContent = 'Í≤åÏûÑÏù¥ ÏùºÏãúÏ†ïÏßÄÎêòÏóàÏäµÎãàÎã§.';
        }
    }
}

function resumeGame() {
    if (gameState === 'paused') {
        gameState = 'playing';
        
        if (elements.gameOverlay) {
            elements.gameOverlay.classList.add('hidden');
        }
        if (elements.gameInfo) {
            elements.gameInfo.textContent = 'Î∞©Ìñ•ÌÇ§Î°ú Î±ÄÏùÑ Ï°∞Ï¢ÖÌïòÏÑ∏Ïöî!';
        }
        
        gameInterval = setInterval(gameLoop, gameStats.gameSpeed);
    }
}

function resetGame() {
    clearInterval(gameInterval);
    
    if (gameStartTime > 0) {
        const sessionTime = Math.floor((Date.now() - gameStartTime) / 1000 / 60);
        totalPlayTime += sessionTime;
        allTimeStats.totalPlayTime += sessionTime;
        localStorage.setItem('snakePlayTime', allTimeStats.totalPlayTime);
    }
    
    gameState = 'ready';
    gameStats.score = 0;
    gameStats.snakeLength = 1;
    gameStats.speed = 1;
    gameStats.foodEaten = 0;
    gameStats.gameSpeed = 200;
    gameStats.slowEffectTime = 0;
    gameStats.freezeTime = 0;
    gameStartTime = 0;
    
    if (elements.gameOverlay) {
        elements.gameOverlay.classList.remove('hidden');
    }
    if (elements.overlayTitle) {
        elements.overlayTitle.textContent = 'üéÆ Í≤åÏûÑ Ï§ÄÎπÑ!';
    }
    if (elements.overlayMessage) {
        elements.overlayMessage.textContent = 'Î∞©Ìñ•ÌÇ§Î•º ÎàåÎü¨ Î±ÄÏùÑ ÏõÄÏßÅÏù¥ÏÑ∏Ïöî';
    }
    if (elements.gameInfo) {
        elements.gameInfo.textContent = 'Î∞©Ìñ•ÌÇ§Î•º ÎàåÎü¨ ÏãúÏûëÌïòÏÑ∏Ïöî!';
    }
    
    const canvas = document.getElementById('gameCanvas');
    if (canvas) {
        canvas.classList.remove('game-over-shake');
    }
    
    initializeGame();
    updateUI();
    draw();
}

function gameLoop() {
    if (gameState !== 'playing') return;
    
    // Î©àÏ∂§ Ìö®Í≥º Ï≤òÎ¶¨
    if (gameStats.freezeTime > 0) {
        gameStats.freezeTime -= gameStats.gameSpeed;
        // Î©àÏ∂∞ÏûàÎäî ÎèôÏïàÏóêÎäî Í≤åÏûÑ Î£®ÌîÑÎßå Í≥ÑÏÜç ÎèåÍ≥† Î±ÄÏùÄ ÏõÄÏßÅÏù¥ÏßÄ ÏïäÏùå
        updateUI();
        draw();
        return;
    }
    
    // Î∞©Ìñ• ÏóÖÎç∞Ïù¥Ìä∏
    direction = { ...nextDirection };
    
    // ÏÜçÎèÑ Í∞êÏÜå Ìö®Í≥º Ï≤òÎ¶¨
    if (gameStats.slowEffectTime > 0) {
        gameStats.slowEffectTime -= gameStats.gameSpeed;
        if (gameStats.slowEffectTime <= 0) {
            // ÏÜçÎèÑ Î≥µÍµ¨
            clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, gameStats.gameSpeed);
        }
    }
    
    // Î±Ä Ïù¥Îèô
    const head = { ...snake[0] };
    head.x += direction.x;
    head.y += direction.y;
    
    // Î≤Ω Ï∂©Îèå Ï≤¥ÌÅ¨
    const gridWidth = Math.floor(canvas.width / GAME_CONFIG.gridSize);
    const gridHeight = Math.floor(canvas.height / GAME_CONFIG.gridSize);
    
    if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
        gameOver();
        return;
    }
    
    // ÏûêÍ∏∞ Î™∏ Ï∂©Îèå Ï≤¥ÌÅ¨
    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver();
        return;
    }
    
    // Ïû•Ïï†Î¨º Ï∂©Îèå Ï≤¥ÌÅ¨
    if (obstacles.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) {
        gameOver();
        return;
    }
    
    snake.unshift(head);
    
    // ÏùåÏãù Î®πÍ∏∞ Ï≤¥ÌÅ¨
    const eatenFoodIndex = foods.findIndex(food => food.x === head.x && food.y === head.y);
    if (eatenFoodIndex !== -1) {
        const eatenFood = foods[eatenFoodIndex];
        
        // Ï†êÏàò Î∞è Í∏∏Ïù¥ Î≥ÄÍ≤Ω
        gameStats.score += eatenFood.score;
        gameStats.snakeLength += eatenFood.lengthChange;
        gameStats.foodEaten++;
        
        // ÌäπÏàò Ìö®Í≥º Ï≤òÎ¶¨
        if (eatenFood.speedEffect === 'slow') {
            gameStats.slowEffectTime = 3000; // 3Ï¥àÍ∞Ñ ÏÜçÎèÑ Í∞êÏÜå
            clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, gameStats.gameSpeed * 1.5);
        } else if (eatenFood.speedEffect === 'freeze') {
            gameStats.freezeTime = 1500; // 1.5Ï¥àÍ∞Ñ Î©àÏ∂§
        }
        
        // ÏùåÏãù Ï†úÍ±∞
        foods.splice(eatenFoodIndex, 1);
        
        // Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        allTimeStats.totalFood++;
        localStorage.setItem('snakeTotalFood', allTimeStats.totalFood);
        
        // ÏÜçÎèÑ Ï¶ùÍ∞Ä (5Í∞úÎßàÎã§)
        if (gameStats.foodEaten % 5 === 0) {
            gameStats.speed++;
            gameStats.gameSpeed = Math.max(80, gameStats.gameSpeed - 15);
            
            if (gameStats.speed > allTimeStats.maxSpeed) {
                allTimeStats.maxSpeed = gameStats.speed;
                localStorage.setItem('snakeMaxSpeed', allTimeStats.maxSpeed);
            }
            
            if (gameStats.slowEffectTime <= 0) {
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, gameStats.gameSpeed);
            }
        }
        
        // ÏÉàÎ°úÏö¥ Í∏∞Î≥∏ ÏÇ¨Í≥º ÏÉùÏÑ± (Ïä§Ìè∞ ÌôïÎ•† ÎåÄÌè≠ Í∞êÏÜå)
        const currentApples = foods.filter(f => f.type === 'apple').length;
        if (currentApples === 0) {
            // Í∏∞Î≥∏ ÏÇ¨Í≥ºÍ∞Ä ÏóÜÏùÑ ÎïåÎßå ÏÉùÏÑ±
            generateFood(FOOD_TYPES.APPLE);
        } else if (currentApples === 1 && gameStats.snakeLength > 15) {
            // Í∏∏Ïù¥ 15 Ïù¥ÏÉÅÏùº ÎïåÎßå Îëê Î≤àÏß∏ ÏÇ¨Í≥º Í∞ÄÎä•ÏÑ± (20% ÌôïÎ•†)
            if (Math.random() < 0.2) {
                generateFood(FOOD_TYPES.APPLE);
            }
        }
        
        // ÌäπÏàò ÏùåÏãù ÏÉùÏÑ± Ï°∞Í±¥
        generateSpecialFoods();
        
        // Ïû•Ïï†Î¨º ÏÉùÏÑ± Ï°∞Í±¥
        generateObstaclesBasedOnLength();
        
        createFoodEffect();
    } else {
        // ÏùåÏãùÏùÑ Î®πÏßÄ ÏïäÏïòÏúºÎ©¥ Íº¨Î¶¨ Ï†úÍ±∞ (ÎèÖÎ≤ÑÏÑØÏùò Í≤ΩÏö∞ Í∏∏Ïù¥Í∞Ä ÎäòÏñ¥ÎÇòÎØÄÎ°ú Ï°∞Ï†ï)
        if (gameStats.snakeLength <= snake.length) {
            snake.pop();
        }
    }
    
    // ÏõÄÏßÅÏù¥Îäî Ïû•Ïï†Î¨º Ïù¥Îèô
    moveObstacles();
    
    updateUI();
    draw();
}

function generateSpecialFoods() {
    // Í∏∏Ïù¥ 10 Ïù¥ÏÉÅ: ÌäπÏàò ÏùåÏãù 1Í∞ú
    if (gameStats.snakeLength >= 10 && foods.filter(f => f.type !== 'apple').length === 0) {
        if (Math.random() < 0.25) { // 25% ÌôïÎ•†
            const specialType = Math.random() < 0.7 ? FOOD_TYPES.GOLDEN : FOOD_TYPES.POISON;
            generateFood(specialType);
        }
    }
    
    // Í∏∏Ïù¥ 30 Ïù¥ÏÉÅ: ÌäπÏàò ÏùåÏãù 2Í∞úÍπåÏßÄ
    if (gameStats.snakeLength >= 30 && foods.filter(f => f.type !== 'apple').length < 2) {
        if (Math.random() < 0.15) { // 15% ÌôïÎ•†
            const specialType = Math.random() < 0.6 ? FOOD_TYPES.GOLDEN : FOOD_TYPES.POISON;
            generateFood(specialType);
        }
    }
}

function generateObstaclesBasedOnLength() {
    // Ïû•Ïï†Î¨º Í∞úÏàòÍ∞Ä Ïù¥ÎØ∏ ÏµúÎåÄÏπòÎ©¥ Ï∂îÍ∞Ä ÏÉùÏÑ± ÏïàÌï®
    if (obstacles.length >= 3) return;
    
    // Í∏∏Ïù¥ 15 Ïù¥ÏÉÅ: Í≥†Ï†ï Ïû•Ïï†Î¨º ÏÉùÏÑ±
    if (gameStats.snakeLength >= 15 && obstacles.length === 0) {
        generateObstacle(OBSTACLE_TYPES.STATIC);
        return; // ÌïòÎÇò ÏÉùÏÑ±ÌñàÏúºÎ©¥ Ïù¥Î≤à ÌîÑÎ†àÏûÑÏóêÏÑúÎäî Ï∂îÍ∞Ä ÏÉùÏÑ± ÏïàÌï®
    }
    
    // Í∏∏Ïù¥ 20 Ïù¥ÏÉÅ: ÏõÄÏßÅÏù¥Îäî Ïû•Ïï†Î¨º ÏÉùÏÑ±
    if (gameStats.snakeLength >= 20 && obstacles.filter(o => o.moving).length === 0) {
        if (Math.random() < 0.03) { // ÌôïÎ•†ÏùÑ ÎÇÆÏ∂∞ÏÑú Îß§ ÌîÑÎ†àÏûÑÎßàÎã§ Ï≤¥ÌÅ¨ÌïòÏßÄ ÏïäÎèÑÎ°ù
            generateObstacle(OBSTACLE_TYPES.MOVING);
            return;
        }
    }
    
    // Ï∂îÍ∞Ä Ïû•Ïï†Î¨º ÏÉùÏÑ± (ÏµúÎåÄ 3Í∞ú) - ÌôïÎ•†ÏùÑ Îçî ÎÇÆÏ∂§
    if (gameStats.snakeLength >= 25 && obstacles.length < 2 && Math.random() < 0.002) {
        const obstacleType = Math.random() < 0.7 ? OBSTACLE_TYPES.STATIC : OBSTACLE_TYPES.MOVING;
        generateObstacle(obstacleType);
        return;
    }
    
    if (gameStats.snakeLength >= 35 && obstacles.length < 3 && Math.random() < 0.001) {
        const obstacleType = Math.random() < 0.6 ? OBSTACLE_TYPES.STATIC : OBSTACLE_TYPES.MOVING;
        generateObstacle(obstacleType);
    }
}

function createFoodEffect() {
    if (canvas) {
        canvas.style.filter = 'brightness(1.3) drop-shadow(0 0 10px #00ff00)';
        setTimeout(() => {
            canvas.style.filter = '';
        }, 150);
    }
}

function gameOver() {
    gameState = 'gameOver';
    clearInterval(gameInterval);
    
    if (gameStartTime > 0) {
        const sessionTime = Math.floor((Date.now() - gameStartTime) / 1000);
        const sessionMinutes = Math.floor(sessionTime / 60);
        allTimeStats.totalSurvivalTime += sessionTime;
        allTimeStats.totalPlayTime += sessionMinutes;
        localStorage.setItem('snakeSurvivalTime', allTimeStats.totalSurvivalTime);
        localStorage.setItem('snakePlayTime', allTimeStats.totalPlayTime);
    }
    
    // Í≤åÏûÑ Ïàò Ï¶ùÍ∞Ä
    allTimeStats.totalGames++;
    localStorage.setItem('snakeTotalGames', allTimeStats.totalGames);
    
    // ÏµúÍ≥†Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏
    let isNewRecord = false;
    if (gameStats.score > gameStats.highScore) {
        gameStats.highScore = gameStats.score;
        localStorage.setItem('snakeHighScore', gameStats.highScore.toString());
        isNewRecord = true;
    }
    
    // ÏµúÎåÄÍ∏∏Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏
    if (gameStats.snakeLength > gameStats.maxLength) {
        gameStats.maxLength = gameStats.snakeLength;
        localStorage.setItem('snakeMaxLength', gameStats.maxLength.toString());
    }
    
    // Ï∫îÎ≤ÑÏä§ ÌùîÎì§Î¶º Ìö®Í≥º
    const canvas = document.getElementById('gameCanvas');
    if (canvas) {
        canvas.classList.add('game-over-shake');
    }
    
    // 1.5Ï¥à ÌõÑ Î™®Îã¨ ÌëúÏãú
    setTimeout(() => {
        if (canvas) {
            canvas.classList.remove('game-over-shake');
        }
        
        if (isNewRecord) {
            if (elements.modalTitle) {
                elements.modalTitle.textContent = 'üèÜ ÏÉàÎ°úÏö¥ ÏµúÍ≥†Í∏∞Î°ù!';
                elements.modalTitle.style.color = '#ffff00';
            }
            if (elements.modalMessage) {
                elements.modalMessage.textContent = 'Ï∂ïÌïòÌï©ÎãàÎã§! ÏÉàÎ°úÏö¥ ÏµúÍ≥†Ï†êÏàòÎ•º Îã¨ÏÑ±ÌñàÏäµÎãàÎã§!';
            }
        } else {
            if (elements.modalTitle) {
                elements.modalTitle.textContent = 'üíÄ Í≤åÏûÑ Ïò§Î≤Ñ!';
                elements.modalTitle.style.color = '#ff0000';
            }
            if (elements.modalMessage) {
                elements.modalMessage.textContent = 'Î±ÄÏù¥ Î≤ΩÏù¥ÎÇò Ïû•Ïï†Î¨ºÏóê Î∂ÄÎî™ÌòîÏäµÎãàÎã§!';
            }
        }
        
        if (elements.finalScore) elements.finalScore.textContent = gameStats.score;
        if (elements.finalLength) elements.finalLength.textContent = gameStats.snakeLength;
        if (elements.finalFood) elements.finalFood.textContent = gameStats.foodEaten;
        if (elements.gameOverModal) elements.gameOverModal.style.display = 'flex';
    }, 1500);
    
    updateUI();
}

function closeModal() {
    if (elements.gameOverModal) {
        elements.gameOverModal.style.display = 'none';
    }
    resetGame();
}

function showHelp() {
    if (elements.helpModal) {
        elements.helpModal.style.display = 'flex';
    }
}

function closeHelp() {
    if (elements.helpModal) {
        elements.helpModal.style.display = 'none';
    }
}

function showStats() {
    if (elements.statsModal) {
        updateStatsModal();
        elements.statsModal.style.display = 'flex';
    }
}

function closeStats() {
    if (elements.statsModal) {
        elements.statsModal.style.display = 'none';
    }
}

function updateStatsModal() {
    const modalHighScore = document.getElementById('modalHighScore');
    const modalMaxLength = document.getElementById('modalMaxLength');
    const modalMaxSpeed = document.getElementById('modalMaxSpeed');
    
    if (modalHighScore) modalHighScore.textContent = gameStats.highScore;
    if (modalMaxLength) modalMaxLength.textContent = gameStats.maxLength;
    if (modalMaxSpeed) modalMaxSpeed.textContent = allTimeStats.maxSpeed;
    
    const modalTotalGames = document.getElementById('modalTotalGames');
    const modalTotalFood = document.getElementById('modalTotalFood');
    const modalPlayTime = document.getElementById('modalPlayTime');
    
    if (modalTotalGames) modalTotalGames.textContent = allTimeStats.totalGames;
    if (modalTotalFood) modalTotalFood.textContent = allTimeStats.totalFood;
    if (modalPlayTime) modalPlayTime.textContent = allTimeStats.totalPlayTime + 'Î∂Ñ';
}

function resetStats() {
    if (confirm('Ï†ïÎßêÎ°ú Î™®Îì† Í∏∞Î°ùÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.')) {
        localStorage.removeItem('snakeHighScore');
        localStorage.removeItem('snakeMaxLength');
        localStorage.removeItem('snakeTotalGames');
        localStorage.removeItem('snakeTotalFood');
        localStorage.removeItem('snakePlayTime');
        localStorage.removeItem('snakeMaxSpeed');
        localStorage.removeItem('snakeSurvivalTime');
        
        gameStats.highScore = 0;
        gameStats.maxLength = 1;
        allTimeStats.totalGames = 0;
        allTimeStats.totalFood = 0;
        allTimeStats.totalPlayTime = 0;
        allTimeStats.maxSpeed = 1;
        allTimeStats.totalSurvivalTime = 0;
        
        updateUI();
        updateStatsModal();
        
        alert('Î™®Îì† Í∏∞Î°ùÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!');
    }
}

function draw() {
    if (!canvas || !ctx) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Î∞∞Í≤Ω Í∑∏ÎùºÎîîÏñ∏Ìä∏
    const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, canvas.width/2
    );
    gradient.addColorStop(0, 'rgba(0, 20, 40, 0.8)');
    gradient.addColorStop(1, 'rgba(0, 10, 20, 0.9)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawFoods();
    drawObstacles();
    drawSnake();
    
    if (gameState === 'ready') {
        drawCenterText('Î∞©Ìñ•ÌÇ§Î•º ÎàåÎü¨ ÏãúÏûë!', '#00ffff');
    }
}

function drawGrid() {
    if (!ctx || !canvas) return;
    
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    const gridWidth = Math.floor(canvas.width / GAME_CONFIG.gridSize);
    const gridHeight = Math.floor(canvas.height / GAME_CONFIG.gridSize);
    
    for (let x = 0; x <= gridWidth; x++) {
        ctx.beginPath();
        ctx.moveTo(x * GAME_CONFIG.gridSize, 0);
        ctx.lineTo(x * GAME_CONFIG.gridSize, canvas.height);
        ctx.stroke();
    }
    
    for (let y = 0; y <= gridHeight; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * GAME_CONFIG.gridSize);
        ctx.lineTo(canvas.width, y * GAME_CONFIG.gridSize);
        ctx.stroke();
    }
}

function drawSnake() {
    if (!ctx || !snake.length) return;
    
    snake.forEach((segment, index) => {
        const x = segment.x * GAME_CONFIG.gridSize;
        const y = segment.y * GAME_CONFIG.gridSize;
        
        if (index === 0) {
            // Î±Ä Î®∏Î¶¨
            const headGradient = ctx.createRadialGradient(
                x + GAME_CONFIG.gridSize/2, y + GAME_CONFIG.gridSize/2, 0,
                x + GAME_CONFIG.gridSize/2, y + GAME_CONFIG.gridSize/2, GAME_CONFIG.gridSize/2
            );
            headGradient.addColorStop(0, '#00ff00');
            headGradient.addColorStop(1, '#008800');
            ctx.fillStyle = headGradient;
        } else {
            // Î±Ä Î™∏ÌÜµ
            const bodyGradient = ctx.createLinearGradient(x, y, x + GAME_CONFIG.gridSize, y + GAME_CONFIG.gridSize);
            const alpha = Math.max(0.3, 1 - (index * 0.05));
            bodyGradient.addColorStop(0, `rgba(0, 255, 0, ${alpha})`);
            bodyGradient.addColorStop(1, `rgba(0, 150, 0, ${alpha})`);
            ctx.fillStyle = bodyGradient;
        }
        
        ctx.fillRect(x + 1, y + 1, GAME_CONFIG.gridSize - 2, GAME_CONFIG.gridSize - 2);
        
        ctx.strokeStyle = index === 0 ? '#ffffff' : 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = index === 0 ? 2 : 1;
        ctx.strokeRect(x + 1, y + 1, GAME_CONFIG.gridSize - 2, GAME_CONFIG.gridSize - 2);
        
        // Î®∏Î¶¨Ïóê Îàà Í∑∏Î¶¨Í∏∞
        if (index === 0) {
            ctx.fillStyle = '#ffffff';
            const eyeSize = GAME_CONFIG.gridSize * 0.15;
            const eyeOffset = GAME_CONFIG.gridSize * 0.25;
            
            let eyeX1, eyeY1, eyeX2, eyeY2;
            if (direction.x === 1) {
                eyeX1 = x + GAME_CONFIG.gridSize - eyeOffset;
                eyeY1 = y + eyeOffset;
                eyeX2 = x + GAME_CONFIG.gridSize - eyeOffset;
                eyeY2 = y + GAME_CONFIG.gridSize - eyeOffset;
            } else if (direction.x === -1) {
                eyeX1 = x + eyeOffset;
                eyeY1 = y + eyeOffset;
                eyeX2 = x + eyeOffset;
                eyeY2 = y + GAME_CONFIG.gridSize - eyeOffset;
            } else if (direction.y === -1) {
                eyeX1 = x + eyeOffset;
                eyeY1 = y + eyeOffset;
                eyeX2 = x + GAME_CONFIG.gridSize - eyeOffset;
                eyeY2 = y + eyeOffset;
            } else {
                eyeX1 = x + eyeOffset;
                eyeY1 = y + GAME_CONFIG.gridSize - eyeOffset;
                eyeX2 = x + GAME_CONFIG.gridSize - eyeOffset;
                eyeY2 = y + GAME_CONFIG.gridSize - eyeOffset;
            }
            
            ctx.beginPath();
            ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

function drawFoods() {
    if (!ctx || !foods.length) return;
    
    const currentTime = Date.now(); // Ìïú Î≤àÎßå Ìò∏Ï∂ú
    const time = currentTime * 0.005;
    
    foods.forEach(food => {
        const x = food.x * GAME_CONFIG.gridSize;
        const y = food.y * GAME_CONFIG.gridSize;
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú ÏãúÍ∞Ñ Í∏∞Î∞ò ÌÅ¨Í∏∞ Î≥ÄÌôî
        const baseScale = 0.8 + Math.sin(time + food.x + food.y) * 0.1; // Í∞Å ÏùåÏãùÎßàÎã§ Îã§Î•∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
        
        // ÏãúÍ∞Ñ Ï†úÌïú ÏùåÏãùÏùò Í≤ΩÏö∞ ÍπúÎπ°ÏûÑ Ìö®Í≥º
        let scale = baseScale;
        if (food.duration) {
            const timeLeft = food.duration - (currentTime - food.createdAt);
            if (timeLeft < 2000) { // 2Ï¥à ÎÇ®ÏúºÎ©¥ ÍπúÎπ°ÏûÑ
                const blink = Math.sin(currentTime * 0.02) > 0;
                if (!blink) return; // ÍπúÎπ°ÏûÑ Ï§ëÏù¥Î©¥ Í±¥ÎÑàÎõ∞Í∏∞
            }
            // ÏãúÍ∞ÑÏù¥ Ï†ÅÍ≤å ÎÇ®ÏùÑÏàòÎ°ù Îçî Îπ†Î•¥Í≤å Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (timeLeft < 3000) {
                scale = baseScale + Math.sin(time * 3) * 0.2;
            }
        }
        
        // Ïù¥Î™®ÏßÄÎ°ú ÏùåÏãù Í∑∏Î¶¨Í∏∞
        const fontSize = GAME_CONFIG.gridSize * scale;
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.fillText(
            food.emoji, 
            x + GAME_CONFIG.gridSize/2, 
            y + GAME_CONFIG.gridSize/2
        );
    });
}

function drawObstacles() {
    if (!ctx || !obstacles.length) return;
    
    obstacles.forEach(obstacle => {
        const x = obstacle.x * GAME_CONFIG.gridSize;
        const y = obstacle.y * GAME_CONFIG.gridSize;
        
        if (obstacle.moving) {
            // ÏõÄÏßÅÏù¥Îäî Ïû•Ïï†Î¨º (ÌïòÎäòÏÉâ)
            const time = Date.now() * 0.005;
            const glow = Math.sin(time) * 0.3 + 0.7;
            
            const movingGradient = ctx.createRadialGradient(
                x + GAME_CONFIG.gridSize/2, y + GAME_CONFIG.gridSize/2, 0,
                x + GAME_CONFIG.gridSize/2, y + GAME_CONFIG.gridSize/2, GAME_CONFIG.gridSize/2
            );
            movingGradient.addColorStop(0, `rgba(100, 150, 255, ${glow})`);
            movingGradient.addColorStop(1, `rgba(50, 100, 200, ${glow})`);
            ctx.fillStyle = movingGradient;
        } else {
            // Í≥†Ï†ï Ïû•Ïï†Î¨º (ÌöåÏÉâ)
            const staticGradient = ctx.createLinearGradient(x, y, x + GAME_CONFIG.gridSize, y + GAME_CONFIG.gridSize);
            staticGradient.addColorStop(0, '#888888');
            staticGradient.addColorStop(1, '#444444');
            ctx.fillStyle = staticGradient;
        }
        
        ctx.fillRect(x + 1, y + 1, GAME_CONFIG.gridSize - 2, GAME_CONFIG.gridSize - 2);
        
        // ÌÖåÎëêÎ¶¨
        ctx.strokeStyle = obstacle.moving ? '#4488ff' : '#666666';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, GAME_CONFIG.gridSize - 2, GAME_CONFIG.gridSize - 2);
    });
}

function drawCenterText(text, color) {
    if (!ctx || !canvas) return;
    
    ctx.fillStyle = color;
    ctx.font = `${Math.floor(GAME_CONFIG.gridSize * 1.5)}px Orbitron`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText(text, canvas.width/2, canvas.height/2);
    
    ctx.fillText(text, canvas.width/2, canvas.height/2);
}

function updateUI() {
    if (elements.score) elements.score.textContent = gameStats.score;
    if (elements.snakeLength) elements.snakeLength.textContent = gameStats.snakeLength;
    if (elements.speed) elements.speed.textContent = gameStats.speed;
    if (elements.highScore) elements.highScore.textContent = gameStats.highScore;
    if (elements.maxLength) elements.maxLength.textContent = gameStats.maxLength;
    if (elements.foodEaten) elements.foodEaten.textContent = gameStats.foodEaten;
}

function goHome() {
    if (confirm('Í≤åÏûÑÏùÑ Ï¢ÖÎ£åÌïòÍ≥† Î©îÏù∏ ÌéòÏù¥ÏßÄÎ°ú ÎèåÏïÑÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?')) {
        clearInterval(gameInterval);
        window.location.href = 'index.html';
    }
}


let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
let isSwiping = false;

// Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
function setupEventListeners() {
    document.addEventListener('keydown', handleKeyDown);
    
    const mobileButtons = document.querySelectorAll('.mobile-btn');
    mobileButtons.forEach(button => {
        button.addEventListener('click', handleMobileControl);
        button.addEventListener('touchstart', handleMobileControl, { passive: true });
    });
    
    window.addEventListener('resize', resizeCanvas);
    setupModalClickEvents();
    
    // ÌÑ∞Ïπò Ïä§ÏôÄÏù¥ÌîÑ
    if (canvas) {
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            isSwiping = true;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            if (!isSwiping) return;
            e.preventDefault();
            
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isSwiping) {
                handleSwipe();
                isSwiping = false;
            }
        }, { passive: false });
    }
}

function handleSwipe() {
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    const minSwipeDistance = 30;
    
    const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);
    const isVertical = Math.abs(deltaY) > Math.abs(deltaX);
    
    if (isHorizontal && Math.abs(deltaX) > minSwipeDistance) {
        if (deltaX > 0) {
            changeDirection('right');
        } else {
            changeDirection('left');
        }
    } else if (isVertical && Math.abs(deltaY) > minSwipeDistance) {
        if (deltaY > 0) {
            changeDirection('down');
        } else {
            changeDirection('up');
        }
    }
}

function setupModalClickEvents() {
    if (elements.helpModal) {
        elements.helpModal.addEventListener('click', (e) => {
            if (e.target === elements.helpModal) {
                closeHelp();
            }
        });
    }
    
    if (elements.statsModal) {
        elements.statsModal.addEventListener('click', (e) => {
            if (e.target === elements.statsModal) {
                closeStats();
            }
        });
    }
    
    if (elements.gameOverModal) {
        elements.gameOverModal.addEventListener('click', (e) => {
            if (e.target === elements.gameOverModal) {
                closeModal();
            }
        });
    }
}

function handleKeyDown(e) {
    switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            e.preventDefault();
            changeDirection('up');
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            e.preventDefault();
            changeDirection('down');
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            e.preventDefault();
            changeDirection('left');
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            e.preventDefault();
            changeDirection('right');
            break;
        case ' ':
            e.preventDefault();
            if (gameState === 'playing') {
                pauseGame();
            } else if (gameState === 'paused') {
                resumeGame();
            }
            break;
        case 'r':
        case 'R':
            resetGame();
            break;
        case 'h':
        case 'H':
            showHelp();
            break;
        case 'Escape':
            if (elements.helpModal && elements.helpModal.style.display === 'flex') {
                closeHelp();
            } else if (elements.statsModal && elements.statsModal.style.display === 'flex') {
                closeStats();
            } else if (elements.gameOverModal && elements.gameOverModal.style.display === 'flex') {
                closeModal();
            } else {
                goHome();
            }
            break;
    }
}

function handleMobileControl(e) {
    e.preventDefault();
    const direction = e.target.getAttribute('data-direction');
    
    if (direction === 'pause') {
        if (gameState === 'playing') {
            pauseGame();
        } else if (gameState === 'paused') {
            resumeGame();
        }
    } else {
        changeDirection(direction);
    }
}

function changeDirection(newDirection) {
    if (gameState === 'ready') {
        // Î∞©Ìñ•ÌÇ§Î°ú Í≤åÏûÑ ÏãúÏûëÌï† ÎïåÎäî Ìï¥Îãπ Î∞©Ìñ•ÏúºÎ°ú ÏãúÏûë
        switch(newDirection) {
            case 'up':
                direction = { x: 0, y: -1 };
                nextDirection = { x: 0, y: -1 };
                break;
            case 'down':
                direction = { x: 0, y: 1 };
                nextDirection = { x: 0, y: 1 };
                break;
            case 'left':
                direction = { x: -1, y: 0 };
                nextDirection = { x: -1, y: 0 };
                break;
            case 'right':
                direction = { x: 1, y: 0 };
                nextDirection = { x: 1, y: 0 };
                break;
        }
        
        // Í≤åÏûÑ ÏãúÏûë
        gameState = 'playing';
        gameStartTime = Date.now();
        
        if (elements.gameOverlay) {
            elements.gameOverlay.classList.add('hidden');
        }
        if (elements.gameInfo) {
            elements.gameInfo.textContent = 'Î∞©Ìñ•ÌÇ§Î°ú Î±ÄÏùÑ Ï°∞Ï¢ÖÌïòÏÑ∏Ïöî!';
        }
        
        gameInterval = setInterval(gameLoop, gameStats.gameSpeed);
        updateGameButton();
        return;
    }
    
    // Í≤åÏûÑ Ï§ë Î∞©Ìñ• Î≥ÄÍ≤Ω
    switch(newDirection) {
        case 'up':
            if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
            break;
        case 'down':
            if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
            break;
        case 'left':
            if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
            break;
        case 'right':
            if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
            break;
    }
}

// ÌéòÏù¥ÏßÄ Ï†ïÎ¶¨
window.addEventListener('beforeunload', () => {
    clearInterval(gameInterval);
    
    if (gameStartTime > 0) {
        const sessionTime = Math.floor((Date.now() - gameStartTime) / 1000 / 60);
        allTimeStats.totalPlayTime += sessionTime;
        localStorage.setItem('snakePlayTime', allTimeStats.totalPlayTime);
    }
});

document.addEventListener('visibilitychange', () => {
    if (document.hidden && gameState === 'playing') {
        pauseGame();
    }
});